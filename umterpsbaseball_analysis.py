# -*- coding: utf-8 -*-
"""Project_0504_06_UMTerpsBaseball_Analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xuDksyYjHc9fmIUmN5oQgp6YwKHjWQGL

#**Baseball Data Analysis**
#**BUDT 0504 team 6**

###Import Dataset into Pandas
"""

import numpy as np
import pandas as pd

df_game = pd.read_excel('https://docs.google.com/spreadsheets/d/1dvzkRAVFYVkE2PNCAL1rIvNBnCTMhIZK/export?format=xlsx')
df_game

df_year = pd.read_excel('https://docs.google.com/spreadsheets/d/1dvzkRAVFYVkE2PNCAL1rIvNBnCTMhIZK/export?format=xlsx',sheet_name='Year')
df_year

"""###EDA"""

df_game.info()

df_game.describe()

home_away_result_counts = df_game[df_game['At'] == 'Home']['Result'].value_counts()
wins = home_away_result_counts['W']
losses = home_away_result_counts['L']
total_games = wins + losses
print(f'University of Maryland wins {round((wins/total_games)*100)} % of the games at Home')
home_away_result_counts = df_game[df_game['At'] == 'Away']['Result'].value_counts()
wins = home_away_result_counts['W']
losses = home_away_result_counts['L']
total_games = wins + losses
print(f'University of Maryland wins {round((wins/total_games)*100)} % of the games Away from Home')

df_year.describe()

df_year.info()

"""##Data PreProcessing
###Deriving new columns for analysis
"""

columns=df_year.columns.to_list()
stripped_columns = [s.strip() for s in columns]
df_year.columns = stripped_columns

# Split the 'Overall' column
split_columns = df_year['Overall'].str.split('-', expand=True)
# Assign the split columns to specific new columns in the DataFrame
df_year['Overall_Wins'] = split_columns[0]
df_year['Overall_Loss'] = split_columns[1]
# Check if there are third parts (draws), otherwise default to 0
df_year['Overall_Draw'] = split_columns[2] if 2 in split_columns else 0
# Convert new columns to integer type
df_year[['Overall_Wins', 'Overall_Loss', 'Overall_Draw']] = df_year[['Overall_Wins', 'Overall_Loss', 'Overall_Draw']].fillna(0).astype(int)

# Split the 'Conference' column
split_columns = df_year['Conference'].str.split('-', expand=True)
# Assign the split columns to specific new columns in the DataFrame
df_year['Conference_Wins'] = split_columns[0]
df_year['Conference_Loss'] = split_columns[1]
# Check if there are third parts (draws), otherwise default to 0
df_year['Conference_Draw'] = split_columns[2] if 2 in split_columns else 0
# Convert new columns to integer type
df_year[['Conference_Wins', 'Conference_Loss', 'Conference_Draw']] = df_year[['Conference_Wins', 'Conference_Loss', 'Conference_Draw']].fillna(0).astype(int)

# Split the 'Home' column
split_columns = df_year['Home'].str.split('-', expand=True)
# Assign the split columns to specific new columns in the DataFrame
df_year['Home_Wins'] = split_columns[0]
df_year['Home_Loss'] = split_columns[1]
# Check if there are third parts (draws), otherwise default to 0
df_year['Home_Draw'] = split_columns[2] if 2 in split_columns else 0
df_year[['Home_Wins', 'Home_Loss', 'Home_Draw']] = df_year[['Home_Wins', 'Home_Loss', 'Home_Draw']].fillna(0).astype(int)

# Split the 'Away' column
split_columns = df_year['Away'].str.split('-', expand=True)
# Assign the split columns to specific new columns in the DataFrame
df_year['Away_Wins'] = split_columns[0]
df_year['Away_Loss'] = split_columns[1]
# Check if there are third parts (draws), otherwise default to 0
df_year['Away_Draw'] = split_columns[2] if 2 in split_columns else 0
df_year[['Away_Wins', 'Away_Loss', 'Away_Draw']] = df_year[['Away_Wins', 'Away_Loss', 'Away_Draw']].fillna(0).astype(int)

# Split the 'Neutral' column
split_columns = df_year['Neutral'].str.split('-', expand=True)
# Assign the split columns to specific new columns in the DataFrame
df_year['Neutral_Wins'] = split_columns[0]
df_year['Neutral_Loss'] = split_columns[1]
# Check if there are third parts (draws), otherwise default to 0
df_year['Neutral_Draw'] = split_columns[2] if 2 in split_columns else 0
df_year[['Neutral_Wins', 'Neutral_Loss', 'Neutral_Draw']] = df_year[['Neutral_Wins', 'Neutral_Loss', 'Neutral_Draw']].fillna(0).astype(int)

"""###Data Visualization"""

import matplotlib.pyplot as plt

# Create a figure and axes for subplots
fig, axes = plt.subplots(nrows=2, ncols=2, figsize=(12, 8))

years = df_year['Year']
tick_positions = years  # Positions on the axis where you want ticks
tick_labels = [str(year) for year in years]  # Labels for these positions, converting year to string


# Plot Overall Wins over the years
axes[0, 0].plot(df_year['Year'], df_year['Overall_Wins'], color='green', marker='o')
axes[0, 0].set_title('Overall Wins over the years')
axes[0, 0].set_xlabel('Year')
axes[0, 0].set_ylabel('Overall Wins')
axes[0, 1].set_xticks(tick_positions)
axes[0, 1].set_xticklabels(tick_labels, rotation=45)

# Plot Overall Wins in conference over the years
axes[0, 1].plot(df_year['Year'], df_year['Conference_Wins'], color='green', marker='o')
axes[0, 1].set_title('Overall Wins in conference over the years')
axes[0, 1].set_xlabel('Year')
axes[0, 1].set_ylabel('Conference Wins')
axes[0, 1].set_xticks(tick_positions)
axes[0, 1].set_xticklabels(tick_labels, rotation=45)


# Plot Overall Losses over the years
axes[1, 0].plot(df_year['Year'], df_year['Overall_Loss'], color='red', marker='o')
axes[1, 0].set_title('Overall Losses over the years')
axes[1, 0].set_xlabel('Year')
axes[1, 0].set_ylabel('Overall Losses')
axes[1, 0].set_xticks(tick_positions)
axes[1, 0].set_xticklabels(tick_labels, rotation=45)


# Plot Overall Losses in conference over the years
axes[1, 1].plot(df_year['Year'], df_year['Conference_Loss'], color='red', marker='o')
axes[1, 1].set_title('Overall Losses in conference over the years')
axes[1, 1].set_xlabel('Year')
axes[1, 1].set_ylabel('Conference Losses')
axes[1, 1].set_xticks(tick_positions)
axes[1, 1].set_xticklabels(tick_labels, rotation=45)


# Adjust layout to prevent overlap
plt.tight_layout()

# Show the plot
plt.show()

import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.ticker import FuncFormatter

plot_data = pd.DataFrame()
venues = ['Home', 'Away', 'Neutral']

for venue in venues:
    total = df_year[f'{venue}_Wins'] + df_year[f'{venue}_Loss'] + df_year[f'{venue}_Draw']
    plot_data[f'{venue}_Wins'] = df_year[f'{venue}_Wins'] / total
    plot_data[f'{venue}_Loss'] = df_year[f'{venue}_Loss'] / total
    plot_data[f'{venue}_Draw'] = df_year[f'{venue}_Draw'] / total

plot_data.index = df_year['Year']

# Function to format the y-axis as percentage
def to_percentage(x, pos):
    return f'{100 * x:.0f}%'

formatter = FuncFormatter(to_percentage)

# Plotting using pandas plot with enhanced y-axis and annotations
fig, axes = plt.subplots(3, 1, figsize=(10, 18), sharex=True)

for i, venue in enumerate(venues):
    ax = plot_data[[f'{venue}_Wins', f'{venue}_Loss', f'{venue}_Draw']].plot(kind='bar', stacked=True, ax=axes[i], color=['g', 'r', 'b'])
    ax.set_title(f'{venue} Win-Loss-Draw by Year (Percentage)')
    ax.set_xlabel('Year')
    ax.set_ylabel('Percentage')
    ax.yaxis.set_major_formatter(formatter)
    ax.set_ylim(0, 1)  # Ensure the y-axis goes from 0% to 100%

    # Annotate each bar
    for p in ax.patches:
        width, height = p.get_width(), p.get_height()
        x, y = p.get_xy()
        ax.text(x + width/2,
        y + height/2,
        f'{100 * height:.0f}%',
        horizontalalignment='center',
        verticalalignment='center',
        color='white',
        fontsize=9,
        rotation=90,
        fontweight='bold')

# Adjust layout and display the plot
plt.tight_layout()
plt.show()

# Initialize dictionaries to hold counts
win_counts = {}
total_counts = {}

# Calculate win counts and total counts for each opponent
for index, row in df_game.iterrows():
    opponent = row['Opponent']
    result = row['Result']

    if opponent not in total_counts:
        total_counts[opponent] = 0
        win_counts[opponent] = 0

    total_counts[opponent] += 1
    if result == 'W':
        win_counts[opponent] += 1

# Calculate win percentages
win_percentages = {opponent: (win_counts[opponent] / total_counts[opponent]) * 100 for opponent in total_counts}

# Convert to DataFrame for easy plotting
win_percentages_df = pd.DataFrame(list(win_percentages.items()), columns=['Opponent', 'Win_Percentage_Opponent'])
win_percentages_df['Opp_Total_Games'] = win_percentages_df['Opponent'].map(total_counts)
win_percentages_df = win_percentages_df.sort_values(by='Win_Percentage_Opponent', ascending=False)


# Filter opponents with more than ten games played
opponents_win_percentage_10games = win_percentages_df[win_percentages_df['Opp_Total_Games'] >= 10]

# Plot the win percentage as a bar chart with increased width
plt.figure(figsize=(20, 10))  # Increase the width and height
bars = plt.bar(opponents_win_percentage_10games['Opponent'], opponents_win_percentage_10games['Win_Percentage_Opponent'], color='blue', width=0.6)  # Adjust bar width if needed
plt.xlabel('Opponent')
plt.ylabel('Win Percentage (%)')
plt.title('Terps Win Percentage Against Each Opponent (Played More Than 5 Times)')
plt.xticks(rotation=90)

# Annotate the bars with the total number of games played
for bar, total_games in zip(bars, opponents_win_percentage_10games['Opp_Total_Games']):
    yval = bar.get_height()
    plt.text(bar.get_x() + bar.get_width()/2, yval + 1, f'{total_games}', ha='center', va='bottom')

plt.tight_layout()
plt.show()

# Initialize dictionaries to hold counts
location_win_counts = {}
location_total_counts = {}

# Calculate win counts and total counts for each location
for index, row in df_game.iterrows():
    location = row['Location']
    result = row['Result']

    if location not in location_total_counts:
        location_total_counts[location] = 0
        location_win_counts[location] = 0

    location_total_counts[location] += 1
    if result == 'W':
        location_win_counts[location] += 1

# Calculate win percentages for each location
location_win_percentages = {location: (location_win_counts[location] / location_total_counts[location]) * 100 for location in location_total_counts}

# Convert to DataFrame for easy plotting
location_win_percentages_df = pd.DataFrame(list(location_win_percentages.items()), columns=['Location', 'Win_Percentage_Loc'])
location_win_percentages_df['Total_Games_Loc'] = location_win_percentages_df['Location'].map(location_total_counts)
location_win_percentages_df = location_win_percentages_df.sort_values(by='Win_Percentage_Loc', ascending=False)

# Filter locations with more than one game played
locations_win_percentage_5_games = location_win_percentages_df[location_win_percentages_df['Total_Games_Loc'] >= 5]

# Increase the width of the graph
plt.figure(figsize=(15, 6))

# Plot the win percentage as a bar chart
bars = plt.bar(locations_win_percentage_5_games['Location'], locations_win_percentage_5_games['Win_Percentage_Loc'], color='blue')
plt.xlabel('Location')
plt.ylabel('Win Percentage (%)')
plt.title('University of Maryland Terrapins Baseball Win Percentage at Each Location')

# Rotate the x-axis labels vertically
plt.xticks(rotation=90)

# Annotate the bars with the total number of games played
for bar, total_games in zip(bars, locations_win_percentage_5_games['Total_Games_Loc']):
    yval = bar.get_height()
    plt.text(bar.get_x() + bar.get_width()/2, yval + 1, f'{total_games}', ha='center', va='bottom')

plt.tight_layout()
plt.show()

"""# Iteration for Report 1 - Aggregating 'Win counts' from Game Sheet year wise"""

# Convert 'Date' column to datetime
df_game['Date'] = pd.to_datetime(df_game['Date'])

# Extract year from 'Date'
df_game['Year'] = df_game['Date'].dt.year

# Aggregating win counts from Game Sheet

df_game_wins = df_game[df_game['Result'] == 'W']

# Group by 'Year' and count occurrences of 'Win'
game_wins = df_game_wins.groupby('Year')['Result'].count()
game_wins = df_game_wins.groupby('Year')['Result'].count().reset_index()

# Rename the column
game_wins = game_wins.rename(columns={'Result': 'Game_Win_Count'})

print(game_wins)

year_total_wins = df_year.groupby('Year')['Overall_Wins'].sum()
year_total_wins

"""## Result Report 1 - Win Counts from Game & Year sheet"""

# Merge the two results
df_wins_total = pd.merge(game_wins, year_total_wins, on='Year', how='outer')

# Fill NaN values with 0
df_wins_total = df_wins_total.fillna(0)

print(df_wins_total)

"""## Iteration for Report 2 - Matching Home games total from Game and Year sheet"""

# Count the occurrences of 'Home' for each year
count_total_home_year = df_game[df_game['At'] == 'Home'].groupby('Year').size().reset_index(name='Count_Total_Home_Year')

print(count_total_home_year)

# Create a new column 'Total_Home_Outcomes' with the sum of 'Home_Wins' and 'Home_Loss'
df_year['Total_Home_Outcomes'] = df_year['Home_Wins'] + df_year['Home_Loss']

# Group by 'Year' and calculate the sum of 'Total_Home_Outcomes' for each year
df_home_outcomes = df_year.groupby('Year')['Total_Home_Outcomes'].sum().reset_index(name='Total_Home_Outcomes')

print(df_home_outcomes)

"""## Result Report 2 - Home total games from Game & Year sheet"""

# Merge the two results
df_home_games = pd.merge(count_total_home_year, df_home_outcomes, on='Year', how='outer')

# Fill NaN values with 0
df_home_games = df_home_games.fillna(0)

print(df_home_games)

"""##Analytical Models

###Preparing Dataset
"""

# Perform a left join on df_game with all_games_against_opponents
merged_df = pd.merge(df_game, win_percentages_df, on='Opponent', how='left')
# Rename the columns for clarity
merged_df = merged_df.rename(columns={'Win_Percentage': 'Opponent_WinPercentage', 'Total_games': 'Opponent_Games_Played'})
# Perform a left join on df_game with location_win_percentages_df
df_train = pd.merge(merged_df, location_win_percentages_df, on='Location', how='inner')
# Rename the columns for clarity
df_train = df_train.rename(columns={'Win_Percentage_Loc': 'Location_winpercentage', 'Total_Games': 'Games_Played_at_Loc'})
df_train

"""### Test Data Extracted from UMTerps Website"""

df_test = pd.read_excel('https://docs.google.com/spreadsheets/d/1eJFScGMHO3mvo_KnjmVZLT3SBt_aQc0o/export?format=xlsx')
#https://docs.google.com/spreadsheets/d//edit?usp=sharing&ouid=109228850686679035801&rtpof=true&sd=true
df_test

# Perform a left join on df_game with location_win_percentages_df
df_test = pd.merge(df_test, location_win_percentages_df, on='Location', how='inner')

# Rename the columns for clarity
df_test = df_test.rename(columns={'Win_Percentage_Loc': 'Location_winpercentage', 'Total_Games': 'Games_Played_at_Loc'})
# Perform a left join on df_game with all_games_against_opponents
df_test = pd.merge(df_test, win_percentages_df, on='Opponent', how='inner')

# Rename the columns for clarity
df_test = df_test.rename(columns={'Win_Percentage': 'Opponent_WinPercentage', 'Total_games': 'Opponent_Games_Played'})
df_test

"""###Linear Regression Model"""

from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import LabelEncoder

# Prepare data for regression
X = df_train[['Win_Percentage_Opponent', 'Opp_Total_Games','Location_winpercentage','Total_Games_Loc']]  # Example features
y = df_train['Result'].map({'W': 1, 'L': 0})  # Target variable
y.fillna(0)
X_test=df_test[['Win_Percentage_Opponent', 'Opp_Total_Games','Location_winpercentage','Total_Games_Loc']]
y_test = df_test['Result'].map({'W': 1, 'L': 0})

from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error
import numpy as np

model = LinearRegression()
model.fit(X, y)

# Make predictions on the test data
y_pred = model.predict(X_test)

# Since Regression gives numeric values we are taking a threshold above which it is W and below is L Deriving the class
prediction=[]
for num in y_pred:
  if num>0.5:
    prediction.append(1)
  elif num == 0.5:
    prediction.append(0.5)
  else:
    prediction.append(0)

"""###Model Evaluation using the derived class"""

from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
import numpy as np

# Calculate R-squared
r_squared = r2_score(y_test, y_pred)
print("R-squared:", r_squared)

# Calculate MAE
mae = mean_absolute_error(y_test, y_pred)
print("Mean Absolute Error:", mae)

# Calculate MSE
mse = mean_squared_error(y_test, y_pred)
print("Mean Squared Error:", mse)

# Calculate RMSE
rmse = np.sqrt(mse)
print("Root Mean Squared Error:", rmse)

#Using Derived class we can further evaluate the model
from sklearn.metrics import confusion_matrix, accuracy_score, precision_score, recall_score, f1_score

# Generate the confusion matrix
cm = confusion_matrix(y_test, prediction)
print("Confusion Matrix:")
print(cm)

# Calculate accuracy, precision, recall, and F1-score
accuracy = accuracy_score(y_test, prediction)
precision = precision_score(y_test, prediction)
recall = recall_score(y_test, prediction)
f1 = f1_score(y_test, prediction)

# Print the classification metrics
print("Accuracy:", accuracy)
print("Precision:", precision)
print("Recall:", recall)
print("F1 Score:", f1)

"""### Logistic Regression using only numeric data"""

import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score, confusion_matrix, roc_curve, roc_auc_score
from sklearn.preprocessing import LabelEncoder

y=df_train['Result']
model = LogisticRegression()
model.fit(X,y)

# print the estimated intercept and coefficients
print("Intercept:", model.intercept_)
print("Coefficients:", model.coef_)

# print the prediction mean accuracy score
accuracy = model.score(X, y)
print("Prediction Mean Accuracy Score:", accuracy)

# predict Loan
y_pred = model.predict(X)

# print the confusion matrix
confusion_mat = confusion_matrix(y, y_pred)
print("Confusion Matrix:")
print(confusion_mat)

# Encode target variable
label_encoder = LabelEncoder()
y_encoded = label_encoder.fit_transform(y)  # This will convert 'W' -> 1, 'L' -> 0

# Calculate probabilities for the positive class
y_prob = model.predict_proba(X)[:, label_encoder.transform(['W'])[0]]

# Calculate the ROC AUC Score
roc_auc = roc_auc_score(y_encoded, y_prob)

# Calculate ROC Curve
fpr, tpr, thresholds = roc_curve(y_encoded, y_prob)

# Plotting the ROC Curve
plt.figure()
plt.plot(fpr, tpr, color='darkorange', lw=2, label=f'ROC curve (area = {roc_auc:.2f})')
plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Receiver Operating Characteristic')
plt.legend(loc="lower right")
plt.show()

# Print the ROC AUC Score
print("ROC AUC Score:", roc_auc)

"""### Logistic Regression with encoding categorical Variables"""

import pandas as pd
from sklearn.preprocessing import LabelEncoder
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, confusion_matrix

# Encode categorical columns
label_encoders = {}
categorical_columns = ['Day', 'At', 'Opponent', 'Location']
for column in categorical_columns:
    le = LabelEncoder()
    df_train[column] = le.fit_transform(df_train[column])
    label_encoders[column] = le  # Store encoder if needed later for inverse_transform

# Prepare features and target
X = df_train[['Day', 'At', 'Opponent', 'Location', 'Win_Percentage_Opponent', 'Opp_Total_Games', 'Location_winpercentage', 'Total_Games_Loc']]
y = df_train['Result']

y = y.map({'W': 1, 'L': 0}).astype(int)

# Initialize and train logistic regression model
model = LogisticRegression(max_iter=1000)  # Increase max_iter if convergence issues occur
model.fit(X, y)

# Predicting the results for test set
y_pred = model.predict(X)

# Evaluating the model
accuracy = accuracy_score(y, y_pred)
conf_mat = confusion_matrix(y, y_pred)

# Display results
print("Intercept:", model.intercept_)
print("Coefficients:", model.coef_)
print("Accuracy on test set:", accuracy)
print("Confusion Matrix:\n", conf_mat)

# print the prediction mean accuracy score
accuracy = model.score(X, y)
print("Prediction Mean Accuracy Score:", accuracy)

# predict Loan
y_pred = model.predict(X)

# print the confusion matrix
confusion_mat = confusion_matrix(y, y_pred)
print("Confusion Matrix:")
print(confusion_mat)


# Calculate probabilities for the positive class
y_prob = model.predict_proba(X)[:, 1]  # Get probabilities for the positive class

# Calculate the ROC AUC Score
roc_auc = roc_auc_score(y, y_prob)  # Ensure to use true labels and probabilities

# Calculate ROC Curve
fpr, tpr, thresholds = roc_curve(y, y_prob)  # Again, use true labels and probabilities

# Plotting the ROC Curve
plt.figure()
plt.plot(fpr, tpr, color='darkorange', lw=2, label='ROC curve (area = {:.2f})'.format(roc_auc))
plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Receiver Operating Characteristic')
plt.legend(loc="lower right")
plt.show()

# Print the ROC AUC Score
print("ROC AUC Score:", roc_auc)
